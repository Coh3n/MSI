(*
Walking
=======

The Walking file includes functions & procedures that have anything to do with
walking. You'll notice the defines ({$IFDEF REFLECTION}) used throughout these
methods; these are used so MSI will still compile if the user decides to exclude
reflection or if reflection is broken. This file handles walking for both SPS
and reflection.

The source for Walking.simba can be found
`here <https://github.com/SRL/MSI/raw/master/MSI/Core/Walking.simba>`_.

*)

(*
MSI_Flag
~~~~~~~~

.. code-block:: pascal

  procedure MSI_Flag(FlagDist: Integer);

MSI's custom flag function. It waits until the flag is within 'FlagDist' from
the player. It also works if, for some reason, the flag has gone off the minimap,
but the player is still moving.

.. note::

  | Author: The MSI Team
  | Last Updated: 26 January 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_WalkToPoint(MSI_GetWalkCoords(0))) then
    MSI_Flag(MIN_FLAG_DISTANCE); // MIN_FLAG_DISTANCE is found in Globals.simba
*)
procedure MSI_Flag(FlagDist: Integer);
var
  t: Integer;
begin
  if (not LoggedIn) then
    Exit;

  repeat
    if (LeaveDangerZone) then
      MSI_Debug('Left danger zone');

    Wait(RandomRange(200, 500));
    t := (GetSystemTime + 12000);

    // If the player is going around an obstacle and the flag goes off the minimap
    if ((not FlagPresent) and (IsMoving)) then
    begin
      MSI_Antiban(RandomRange(300, 1000), ANTI_BAN_CHANCE);
      Continue;
    end;

    if (FlagDistance <= FlagDist) or (not IsMoving) then
      Exit;

    MSI_FindRandoms(False);
    MSI_AntiBan(RandomRange(200, 800), ANTI_BAN_CHANCE);

    MSI_SubDebug('Flag distance: '+IntToStr(FlagDistance));

  until((not (FlagPresent)) and (not (IsMoving))) or (t < GetSystemTime);
end;

(*
MSI_GetMyPos
~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_GetMyPos(): TPoint;

Gets the player's position by using either SPS or reflection depending on how
the user has setup the script.

.. note::

  | Author: Coh3n
  | Last Updated: 28 August 2011 by Coh3n

Example:

.. code-block:: pascal

  var
    playerPos: TPoint;
  begin
    playerPos := MSI_GetMyPos();
    ...
*)
function MSI_GetMyPos(): TPoint;
begin
  if (MSI_HookBroken[HOOK_WALKING]) then
  begin
    {$IFDEF SPS}
    result := SPS_GetMyPos();
    {$ENDIF}
  end else begin
    {$IFDEF REFLECTION}
    result := r_GetMyPos();
    {$ENDIF}
  end;
end;

(*
MSI_WaitTile
~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_WaitTile(Tile: TPoint): Boolean;

Simple, yet effective function used as a substitute for Flag functions.
MSI_WaitTile returns true with 'Tile' is on the minimap. See MSI_WalkTile to
see exactly how it's used.

.. note::

  | Author: Coh3n
  | Last Updated: 26 January 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_ClickTile(i)) then
    MSI_WaitTile(i + 1); // Waits for the next tile in the path
*)
function MSI_WaitTile(Tile: TPoint): Boolean;
{$IFDEF REFLECTION}
var
  t: Integer;
{$ENDIF}
begin
  result := false;

  if (not LoggedIn) then
    Exit;

  {$IFDEF REFLECTION}
  t := GetSystemTime + 15000; // Maximum wait time is 15 seconds
  repeat
    clickNorth(true);

    if (LeaveDangerZone) then
      MSI_Debug('Left danger zone');

    if (r_tileOnMM(tile)) then
    begin
      result := true;
      break;
    end;

    MSI_WaitWhileResting;
    MSI_FindRandoms(False);
    MSI_AntiBan(RandomRange(200, 800), ANTI_BAN_CHANCE);
    Wait(RandomRange(200, 300));
  until(Result or (GetSystemTime > t) or (not LoggedIn));
  {$ENDIF}
end;

(*
MSI_ClickTile
~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_ClickTile(Tile: TPoint): Boolean;

Checks to see if the player is near 'Tile', if so, returns true, otherwise it
will verify the tile is on the minimap and return true when clicked.

.. note::

  | Author: marpis
  | Last Updated: 27 March 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_ClickTile(Point(1234, 4321))) then
    MSI_Debug('Clicked tile');
*)
function MSI_ClickTile(Tile: TPoint): Boolean;
{$IFDEF REFLECTION}
var
  MP: TPoint;
{$ENDIF}
begin
  result := false;

  if (not LoggedIn) then
    Exit;

  {$IFDEF REFLECTION}
  MP := r_TileToMM(Tile);

  if (Distance(MP.X, MP.Y, MMCX, MMCY) <= 5) then
  begin
    MSI_Debug('Already near tile');
    Result := True;
    Exit;
  end;

  if (r_TileOnMM(Tile)) then
  begin
    Result := MSI_MultiMouse(MP.X, MP.Y, 40, 4, false);
    RunEnergy(40);
  end;
  {$ENDIF}
end;

(*
MSI_PointOnMM
~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_PointOnMM(p: TPoint; var Coord: TPoint): Boolean;

Returns try if the point, p, is on the minimap. P can be a tile or an SPS point.
The coordinates on the minimap are set to 'Coord'.

.. note::

  | Author: Coh3n
  | Last Updated: 27 February 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_PointOnMM(Path[i], p)) then
    Mouse(p.x, p.y, 3, 3, True);
*)
function MSI_PointOnMM(p: TPoint; var Coord: TPoint): Boolean;
begin
  if (not LoggedIn) then
    Exit;

  if (MSI_HookBroken[HOOK_WALKING]) then
    {$IFDEF SPS}
    Coord := SPS_PosToMM(p)
    {$ELSE}
    Wait(50)
    {$ENDIF}
  else
    {$IFDEF REFLECTION}
    Coord := r_TileToMM(p);
    {$ELSE}
    Wait(50);
    {$ENDIF}

  Result := rs_OnMinimap(Coord.x, Coord.y);
  MSI_SubDebug('MSI_PointOnMM'+ToStr(p)+': ' + BoolToStr(Result));
end;

(*
MSI_ValidSubLoc
~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_ValidSubLoc(loc: TLocation; subIndex: integer): boolean;

Returns true if the player is autoing an object that appears in the sub location
of the location 'loc' and sub location element 'subIndex'.


.. note::

  | Author: Coh3n
  | Last Updated: 07 September 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_ValidSubLoc(MSI_Locations[LOC_VE_BANK], i)) then
    MSI_Relocate(LOC_VE_BANK);
*)
function MSI_ValidSubLoc(loc: TLocation; subIndex: integer): boolean;
var
  i: integer;
  objs: TIntegerArray;
  exceptions: TIntegerArray;
begin
  result := loc.atBank; // always valid if the location is a bank

  // spawning point is valid; if more locations are added, an array should be used
  exceptions := [LOC_LB_SPAWN, LOC_KJ_STILES];
  if (not result) then
    result := (inIntArray(exceptions, loc.constant));

  if (not result) then
  begin
    objs := MSI_GetPlayerObjects();

    for i := 0 to high(loc.subLocs[subIndex].objects) do
      if (inIntArray(objs, loc.subLocs[subIndex].objects[i])) then
      begin
        result := true;
        break;
      end;
  end;

  if (not result) then
    MSI_SubDebug('Not a valid sub-location: ' + loc.subLocs[subIndex].name);
end;

(*
MSI_Relocate
~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_Relocate(Loc: Integer): Boolean;

Relocates the player to the location 'Loc'. Only relocates if the player is
near the location. Returns true if relocation was successful.

.. note::

  | Author: Coh3n and NCDS
  | Last Updated: 21 August 2011 by NCDS

Example:

.. code-block:: pascal

  if (MSI_Relocate(LOC_VE_MINE)) then
    MSI_Debug('Successfully relocated');
*)
function MSI_Relocate(Loc: Integer): Boolean;
var
  hSubLoc, i, cP: integer;
  p, mPos: TPoint;
  areaTPA: TPointArray;
  local_subLocs: TSubLocArray;
  box: TBox;
begin
  if (not loggedIn) then
    exit;

  MSI_AddHeader('MSI_Relocate (' + MSI_Locations[loc].Name + ')');

  if (Length(MSI_Locations[loc].subLocs) < 1) then
  begin
    MSI_SubDebug('No relocation points for ' + MSI_Locations[loc].Name);
    result := true;
  end;

  if (not result) then
  begin
    mPos := MSI_GetMyPos();

    with MSI_Locations[Loc] do
    begin
      // check to see if player's in the last box, if so, invert the boxes
      cP := MSI_Players[CurrentPlayer].CurrentPoint;
      hSubLoc := high(subLocs);

      if (cP = hSubLoc) then
      begin
        setLength(local_subLocs, (hSubLoc + 1));

        for i := hSubLoc downto 0 do
          local_subLocs[hSubLoc - i] := subLocs[i];

        subLocs := local_subLocs;
        cp := (hSubLoc - cP);
      end;

      MSI_Players[CurrentPlayer].CurrentPoint := cP;

      // loop through each "subLoc"
      for i := cP to hSubLoc do
      begin
        // no point in relocating to a location that doesn't have the object we want
        if (not MSI_ValidSubLoc(MSI_Locations[loc], i)) then
          continue;

        if (MSI_HookBroken[HOOK_WALKING]) then
          box := subLocs[i].spsBox
        else
          box := subLocs[i].tileBox;

        MSI_BoxToMM(box);

        // if player is already in box, continue
        if (pointInBox(mPos, box)) then
        begin
          if (i = hSubLoc) then
          begin
            MSI_Debug('Already at ' + MSI_Locations[loc].name);
            result := true;
          end;

          continue;
        end;

        MSI_FindRandoms(true);

        result := MSI_PointOnMM(middleBox(box), p);
        if (not result) then
        begin
          // create a TPA from the subLoc's box
          areaTPA := TPAFromBox(box);
          sortTPAfrom(areaTPA, mPos);

          if (length(areaTPA) > 0) then
            result := MSI_PointOnMM(areaTPA[0], p); // closest point to player
        end;

        if (result) then
        begin
          mouse(p.x, p.y, random(5), random(5), true);
          MSI_Debug('Relocating to box: ' + subLocs[i].name);

          setAngle(MSI_Locations[loc].subLocs[i].camera);
          makeCompass(MSI_Locations[loc].subLocs[i].compass);

          cP := i;
          MSI_Flag(0);
          break;
        end else
          cP := 0;
      end;
    end;
  end;

  MSI_Players[CurrentPlayer].CurrentPoint := cP;
  MSI_CloseHeader('MSI_Relocate: ' + boolToStr(result));
end;

(*
MSI_AtLocation
~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_AtLocation(loc: integer; relocate: boolean): boolean;

Returns true if the player is at the location 'Loc'. Works with both reflection
and SPS. If the player isn't at the location and 'Relocate' is set to true,
will call MSI_Relocate.

.. note::

  | Author: Coh3n
  | Last Updated: 27 August 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_AtLocation(LOC_VE_BANK, True)) then
    MSI_Debug('We are at Varrock East Bank');
*)
function MSI_AtLocation(loc: integer; relocate: boolean): boolean;
var
  i: integer;
  box: TBox;
  mPos: TPoint;
begin
  if (not loggedIn) then
    exit;

  if (loc = LOC_POWER_SKILL) then
  begin
    MSI_SubDebug('Powerskilling, no defined location');
    result := true;
  end;

  MSI_AddHeader('MSI_AtLocation');
  mPos := MSI_GetMyPos();

  with MSI_Locations[loc] do
  begin
    for i := 0 to high(subLocs) do
    begin
      if (not MSI_ValidSubLoc(MSI_Locations[loc], i)) then
        continue;

      MSI_Debug('Checking sub-location: ' + subLocs[i].name);

      if (MSI_HookBroken[HOOK_WALKING]) then
        box := subLocs[i].spsBox
      else
        box := subLocs[i].tileBox;

      if (pointInBox(mPos, box)) then
      begin
        result := true;
        setAngle(subLocs[i].camera);
        makeCompass(subLocs[i].compass);

        MSI_BoxToMM(box);
        MSI_Debug('Player is at ' + subLocs[i].name);
        break;
      end else
        if (i = high(subLocs)) then
          if (relocate) then
            result := MSI_Relocate(loc);
    end;

    if (not Result) then
      MSI_Debug('Player not at ' + name)
    else
      MSI_Players[CurrentPlayer].Location := constant;
  end;

  MSI_CloseHeader('MSI_AtLocation: ' + boolToStr(Result));
end;


(*
MSI_GetCorrectPath
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_GetCorrectPath(path: TPath; toLoc: boolean): T2DPointArray;

Will get the correct path from the 'path' record. If 'toLoc', will invert the
path's Reflection or SPS paths.

.. note::

  | Author: Coh3n
  | Last Updated: 21 July 2011 by Coh3n

Example:

.. code-block:: pascal

  MSI_GetCorrectPath(MSI_Scripts[SCRIPT_VE_MINE].PathInfo, MSI_HookBroken[HOOK_WALKING], True);
*)
function MSI_GetCorrectPath(path: TPath; toLoc: boolean): T2DPointArray;
var
  s: string;
begin
  if (not loggedIn) then
    exit;

  if (toLoc) then                // Start loc -> End loc
    if (MSI_HookBroken[HOOK_WALKING]) then
      result := path.color
    else
      result := path.reflection
  else                           // End loc -> Start loc
    if (MSI_HookBroken[HOOK_WALKING]) then
      result := MSI_MirrorATPA(path.color)
    else
      Result := MSI_MirrorATPA(path.reflection);

  if (MSI_HookBroken[HOOK_WALKING]) then
    s := 'Color'
  else
    s := 'Reflection';

  MSI_SubDebug(s+' Path: '+toStr(result));
end;

(*
MSI_SetPlayerLoc
~~~~~~~~~~~~~~~~

.. code-block:: pascal

  procedure MSI_SetPlayerLoc();

Returns a walkable path from the location (loc) record given.  Uses the middle
point of each TLocation.SubLocs tile and sps boxes.

.. note::

  | Author: Coh3n
  | Last Updated: 23 August 2011 by Coh3n

Example:

.. code-block:: pascal

  path := MSI_PathFromLoc(MSI_Locations[LOC_VE_MINE]);
*)
function MSI_PathFromLoc(loc: TLocation): TPointArray;
var
  i: integer;
begin
  if (not loggedIn) then
    exit;

  setLength(result, length(loc.subLocs));

  for i := 0 to high(loc.subLocs) do
    if (MSI_HookBroken[HOOK_WALKING]) then
      result[i] := middleBox(loc.subLocs[i].spsBox)
    else
      result[i] := middleBox(loc.subLocs[i].tileBox);
end;

(*
MSI_WalkColorPath
~~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_WalkColorPath(Points: TPointArray): Boolean;

Uses SPS's path walking to walk the path specified by 'Points'.  Each script's
path is defined with the script's record in Scripts.simba.

.. note::

  | Author: Coh3n
  | Last Updated: 27 February 2011 by Coh3n

Example:

.. code-block:: pascal

  with MSI_Players[CurrentPlayer] do
    MSI_WalkColorPath(Scripts[CurrentScript].PathInfo.Color);
*)
function MSI_WalkColorPath(Points: TPointArray): Boolean;
begin
  if (not LoggedIn) then
    Exit;

  result := false;

  {$IFDEF SPS}
  Result := SPS_WalkPath(Points);
  {$ENDIF}
end;

(*
MSI_WalkTilePath
~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_WalkTilePath(TPA: TPointArray): Boolean;

Walks the entire tile path (tPath). Uses MSI_WaitTile for every tile except the
last one (uses MSI_Flag(0) instead) to ensure the player has stopped moving
before searching for objects on the mainscreen.

.. note::

  | Author: marpis & Coh3n
  | Last Updated: 23 June 2011 by Coh3n

Example:

.. code-block:: pascal

  if (MSI_WalkTilePath(TilePathHere)) then
    MSI_Debug('Walked path');
*)
function MSI_WalkTilePath(TPA: TPointArray): Boolean;
{$IFDEF REFLECTION}
var
  h, i, t: Integer;
  mPos: TPoint;
  stopMoving: Boolean;
{$ENDIF}
begin
  result := false;

  if (not LoggedIn) then
    Exit;

  {$IFDEF REFLECTION}
  with MSI_Players[CurrentPlayer] do
  begin
    t := GetSystemTime + (Length(TPA) * 60 + 180) * 1000; // A minute for each tile + 3 minutes
    h := High(TPA);

    repeat
      for i := h downto 0 do
      begin
        stopMoving := (i = h);

        if (not MSI_ClickTile(TPA[i])) then
        begin
          if (i = 0) then
            break;

          Continue;
        end else begin
          MSI_Debug('Clicked Tile Path Element ['+toStr(i)+']: '+toStr(TPA[i]));

          if (stopMoving) then
          begin
            clickNorth(true);
            MSI_Flag(10);
          end else
            MSI_WaitTile(TPA[i + 1]);
        end;

        mPos := r_GetMyPos;
        Result := (Distance(mPos.x, mPos.y, TPA[h].x, TPA[h].y) <= 10);
        Break;
      end;

      if ((not result) and (i = 0)) then
      begin
        MSI_Debug('No points are on the minimap');
        break;
      end;
    until(Result or (GetSystemTime > t));
  end;
  {$ENDIF}
end;

(*
MSI_WalkPath
~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_WalkPath(pathInfo: TPath; toLoc: boolean): boolean;

Walks the entire path (PathInfo), including obstacles. Returns true if the
player is at the ending location. 'inverted' is used to determine which
obstacles to load since they may be different depending on the player's
location.

.. note::

  | Author: marpis & Coh3n
  | Last Updated: 21 July 2011 by Coh3n

Example:

.. code-block:: pascal

  MSI_WalkPath(MSI_Scripts[SCRIPT_VE_MINE].PathInfo, true);
*)
function MSI_WalkPath(pathInfo: TPath; toLoc: boolean): boolean;
var
  regPath: T2DPointArray;
  locPath: TPointArray;
  walked: function(TPA: TPointArray): Boolean;
  i, h, t, endLocation: integer;
  done: boolean;
  intObs: TIntegerArray;
  obs: TObstacle;
begin
  if (not loggedIn) then
    exit;

  MSI_AddHeader('MSI_WalkPath');

  if (MSI_HookBroken[HOOK_WALKING]) then
    walked := @MSI_WalkColorPath
  else
    walked := @MSI_WalkTilePath;

  regPath := MSI_GetCorrectPath(pathInfo, toLoc);
  locPath := MSI_MirrorTPA(MSI_PathFromLoc(MSI_Locations[pathInfo.endLoc]));

  // make sure we're passing the right obstacles
  if (toLoc) then
  begin
    endLocation := pathInfo.endLoc;
    intObs := pathInfo.obstacles[OBS_LOC_TO];
  end else begin
    endLocation := pathInfo.startLoc;
    intObs := pathInfo.obstacles[OBS_LOC_FROM];
  end;

  t := (getSystemTime + (length(regPath) * 60 + 180) * 1000);
  h := high(regPath);

  while ((not result) and (getSystemTime < t) and (not done)) do
  begin

	  for i := 0 to h do
      with MSI_Players[CurrentPlayer] do
		  begin
        // Walk the leg of the path
			  if (not walked(regPath[i])) then // regular path
          if ((not walked(locPath)) and (not walked(regPath[i]))) then // location's path then regular path (for multiple sub-locations
            if (i = h) then
            begin
              done := true;
              break;
            end else
              continue;

        // Handle the obstacle
        if (length(intObs) > 0) then
          if (i <> h) then // length of obstacles is always 1 less than path regPath
          begin
            obs := MSI_GetObstacle(intObs[i]);
            if (not MSI_SolveObstacle(obs)) then
            begin
              reportInfo.falseReason := 'Failed to pass obstacle: ' + obs.name;
              MSI_Debug('Failed to pass obstacle: ' + obs.name);
              done := true;
              break;
            end;
          end;

        // Return true if the player is at the ending location
		    if (MSI_AtLocation(endLocation, (i = h))) then
		    begin
		      result := true;
		      break;
		    end;
		  end;
  end;

  if (not result) then
    MSI_Debug('Failed walk (to loc: '+boolToStr(toLoc)+'): ' + pathInfo.name);

	MSI_CloseHeader('MSI_WalkPath: ' + boolToStr(result));
end;

(*
MSI_DeathWalk
~~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_DeathWalk: Boolean;

Attempts to walk to the starting location for each respective script if the
player is lost. Teleports home and walks back if need be.  Keep in mind that
currently this function doesn't support SPS as SPS requires the maps to be
loaded and until we can figure out a fast way to loop through EVERY bitmap, SPS
will not be supported for Death Walking.

.. note::

  | Author: NCDS
  | Last Updated: 21 July 2011 by Coh3n

Example:

.. code-block:: pascal

  if MSI_DeathWalk then
    MSI_Debug('Back on track!');
*)
function MSI_DeathWalk: Boolean;
var
  script: TScript;
  i: integer;
  home: boolean;
  pathInfo: TPath;
(*
  {$IFDEF SPS}
  areas_old: TStringArray;
  {$ENDIF}
*)
begin
  if (not loggedIn) then
    exit;

  MSI_AddHeader('MSI_DeathWalk');

  if (MSI_HookBroken[HOOK_WALKING]) then
  begin
    MSI_Debug('Function not supported without Reflection!');
    MSI_CloseHeader('MSI_DeathWalk: '+boolToStr(result));
    exit;
  end;

  script := MSI_Scripts[MSI_Players[CurrentPlayer].scripts[CurrentScript].name];
  pathInfo := MSI_Locations[script.pathInfo.startLoc].deathPath;

  if (length(pathInfo.reflection) <= 0) then
  begin
    MSI_Debug('No death path for location: '+MSI_Locations[script.pathInfo.startLoc].name);
    MSI_CloseHeader('MSI_DeathWalk: '+boolToStr(result));
    exit;
  end;

(*
  !!!!! See function header as to why these are commented out !!!!!

  // set the SPS areas (set here to increase speed as SPS does take time)
  if (MSI_HookBroken[HOOK_WALKING]) then
  begin
    {$IFDEF SPS}
    areas_old := SPS_Areas;
    SPS_Areas := MSI_Locations[script.pathInfo.startLoc].deathPath.SPSAreas;
    MSI_Debug('New SPS Areas: '+toStr(SPS_Areas));
    SPS_Loaded := false;
    {$ENDIF}
  end;
*)

  // check to see if the player is already in Lumbridge
  home := MSI_AtLocation(LOC_LB_SPAWN, true);

  // tries to walk the path; maybe we're already close to it
  if (not home) then
    result := MSI_WalkPath(pathInfo, true);

  // teleport home!
  if ((not result) and (not home)) then
    if (MSI_ClickSpell(SPELL_TELE_HOME)) then // teleport home
    begin
      MSI_Debug('Waiting to spawn in Lumbridge');

      for i := 1 to 45 do  // 45 seconds
      begin
        wait(1000);
        if (MSI_AtLocation(LOC_LB_SPAWN, false)) then
        begin
          home := true;
          break;
        end;
      end;
    end;

  // Walk back to the script's starting location
  if (not result) then
    if (home) then
    begin
      clickNorth(true);
      result := MSI_WalkPath(pathInfo, true);
    end else begin
      MSI_Debug('Didn''t spawn after 45 seconds');
      result := false;
    end;

  if (result) then
    MSI_Players[CurrentPlayer].ReportInfo.FalseReason := '';
(*
  // set areas back to what they were
  if (MSI_HookBroken[HOOK_WALKING]) then
  begin
    {$IFDEF SPS}
    SPS_Areas := areas_old;
    MSI_Debug('New SPS Areas: '+toStr(SPS_Areas));
    SPS_Loaded := false;
    {$ENDIF}
  end;
*)
  MSI_CloseHeader('MSI_DeathWalk: '+boolToStr(result));
end;

(*
MSI_PerformWalk
~~~~~~~~~~~~~~~

.. code-block:: pascal

  function MSI_PerformWalk(pathInfo: TPath; toLoc: boolean): boolean;

Will walk the path "pathInfo".  Takes into consideration both color and
reflection paths depending on the user's preference as well as the current
state of reflection.  Also uses MSI's death walking feature.

.. note::

  | Author: Coh3n
  | Last Updated: 21 July 2011 by Coh3n

Example:

.. code-block:: pascal

  // Walks to VE mine only if your player is set to use SCRIPT_VE_MINER
  MSI_PerformWalk(MSI_Scripts[SCRIPT_VE_MINE].PathInfo, true);
*)
function MSI_PerformWalk(pathInfo: TPath; toLoc: boolean): boolean;
begin
  if (not loggedIn) then
    exit;

  MSI_FindRandoms(true);
  result := MSI_WalkPath(pathInfo, toLoc);

  if (not result) then
    if (MSI_DeathWalk) then
      result := MSI_WalkPath(pathInfo, toLoc);

  if (not result) then
    with MSI_Players[currentPlayer] do
      if (toLoc) then
        reportInfo.falseReason := 'FAIL: Walk path '+pathInfo.name
      else
        reportInfo.falseReason := 'FAIL: Walk path (inverted) '+pathInfo.name
end;

